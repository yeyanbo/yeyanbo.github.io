<!DOCTYPE html>
<html>
    <head>
        <title> marboo.template </title>
        <meta charset="utf-8" />
        <meta http-equiv="Content-Type" content="text/html; charset=UTF-8" />
        <meta name="date" content="2013-02-03 18:46:57" />
        <meta name="generator" content="Marboo 0.7: http://marboo.biz" />

        <link rel="stylesheet" type="text/css" href="/media/css/bootstrap.css" media="screen" />
        <link rel="stylesheet" type="text/css" href="/media/css/marboo.css" media="screen" />

        <script type="text/javascript">
          var _gaq = _gaq || [];
          _gaq.push(['_setAccount', 'UA-75936-16']);
          _gaq.push(['_trackPageview']);
          (function() {
            var ga = document.createElement('script'); ga.type = 'text/javascript'; ga.async = true;
            ga.src = ('https:' == document.location.protocol ? 'https://ssl' : 'http://www') + '.google-analytics.com/ga.js';
            var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(ga, s);
          })();
            window.onbeforeunload = function() {
                //marboo.save(document.getElementById("source").value);
            }
            var getContent = function () {
                return document.getElementById("source").value
            }
        </script>
    </head>
    <body>
      <h1 class="title">peg/leg 语法解析</h1>

<div class="contents topic" id="table-of-contents">
<p class="topic-title first">Table of Contents</p>
<ul class="simple">
<li><a class="reference internal" href="#id1" id="id7">简单示例</a></li>
<li><a class="reference internal" href="#peg" id="id8">PEG语法</a></li>
<li><a class="reference internal" href="#leg" id="id9">LEG语法</a></li>
<li><a class="reference internal" href="#id2" id="id10">自定义解析器</a></li>
<li><a class="reference internal" href="#leg-example-extending-the-parser-s-context" id="id11">LEG EXAMPLE: EXTENDING THE PARSER'S CONTEXT</a></li>
<li><a class="reference internal" href="#diagnostics" id="id12">DIAGNOSTICS</a></li>
<li><a class="reference internal" href="#id5" id="id13">使用注意事项</a></li>
<li><a class="reference internal" href="#id6" id="id14">Leg解析语法示例: 桌面型计算器</a></li>
</ul>
</div>
<p>PEG是Parsing Expression Grammar的縮寫，是由 MIT的Bryan Ford 所提出用來定義語法的context-free grammar。作者網頁上也列了根據他的研究所寫出的不同語言的實作版本，最為人所知的當然還是C語言版 ，也就是peg與leg這兩個工具的來源。</p>
<p>基本上的使用，如果之前有lex/yacc或Regular expression的經驗應該可以快速上手，下面稍微列一下定義：</p>
<ul class="simple">
<li>name &lt;- pattern，不同於yacc，是以&lt;-作為assign operator</li>
<li>seq1 / seq2 / seq3，不同於yacc，是以/作為OR</li>
<li>. match任一字元</li>
<li>[characters] 括號內的任一字元， [^0-9] 開頭的^是除了特定字元外的意思</li>
<li>( pattern ) 將括號內的pattern歸為一組</li>
<li>&lt; &gt; 會將兩者內的字元累積起來，放至yytext變數中供人使用</li>
<li>? 有或無， + 至少一個或以上， * 無或一個或以上</li>
</ul>
<p>以上是基本的語法元素，PEG也定義了如果對這些元素作條件判斷：</p>
<ul>
<li><dl class="first docutils">
<dt>Predicate 為有著成功或失敗狀態的構詞單位，失敗時不會消耗掉input，</dt>
<dd><ul class="first last simple">
<li>&amp; element表示以元素匹配为true</li>
<li>! element表示以元素不匹配为true（著名的例子是以!.作为文件的结束EOF）</li>
<li>&amp; { action } 是特殊的断言，如果action回傳為true，則繼續執行剩餘的element，為false則尋找是否有替代的rule。</li>
</ul>
</dd>
</dl>
</li>
</ul>
<p>在C和Go版本的實作中，以上三種類型分別被稱為PeekFor, PeekNot, Predicate</p>
<p>LEG
因為yacc的悠久歷史，導致許多的project都是使用yacc所定義的語法，如果要想轉換到PEG上還會因為功能上的差異而花一番功夫，於是C版本便提供了與yacc相容性較高的leg作為解決方案。</p>
<p>LEG在定義上與PEG的不同之處在於：</p>
<ul class="simple">
<li>name = pattern，改用了=來作為assign operator</li>
<li>seq1 | seq2，與yacc相同用|來作OR</li>
<li>rule name可以使用 -，像是rule-name，會被轉換為rule_name，也可以單獨使用-</li>
<li>; 可以被用來結束一個pattern (optional)</li>
<li>%{ text... %} 會將text部份全部copy到生成的go source code的開頭</li>
<li>%% 會結束rule宣告的section，接下來所有的text會被複製到go source code的結尾</li>
<li>exp ~ {action}，只有在前面失敗的時候才會呼叫 action</li>
<li>$$ = value，大概是最大也最重要的不同，LEG可以指定該rule回傳的semantic value，value type都一樣，預設是int，在C版本中是用YYSTYPE來指定</li>
<li>identifier:name，承上，因為可以指定semantic value，所以提供了自定變數名稱的方式來代表回傳的semantic value</li>
</ul>
<div class="section" id="id1">
<h1><a class="toc-backref" href="#id7">简单示例</a></h1>
<p>The  following peg input specifies a grammar with a single rule (called 'start') that is satisfied when the input contains  the  string  &quot;username&quot;.</p>
<blockquote>
start &lt;- &quot;username&quot;</blockquote>
<p>(The  quotation  marks  are not part of the matched text; they serve to indicate a literal string to be matched.)  In other words, yyparse() in the  generated  C  source  will  return non-zero only if the next eight characters read from the input spell the word &quot;username&quot;.  If the input contains  anything  else, yyparse() returns zero and no input will have been consumed.  (Subsequent calls to yyparse() will also  return  zero, since  the  parser is effectively blocked looking for the string &quot;username&quot;.)  To ensure progress we can add an  alternative  clause  to  the 'start'  rule that will match any single character if &quot;username&quot; is not found.</p>
<blockquote>
<dl class="docutils">
<dt>start &lt;- &quot;username&quot;</dt>
<dd>/ .</dd>
</dl>
</blockquote>
<p>yyparse() now always returns non-zero (except at the very  end  of  the input).  To do something useful we can add actions to the rules.  These actions are performed after a complete match is  found  (starting  from the  first  rule)  and are chosen according to the 'path' taken through the grammar to match the input.  (Linguists  would  call  this  path  a 'phrase marker'.)</p>
<pre class="literal-block">
start &lt;- &quot;username&quot;    { printf(&quot;%s\n&quot;, getlogin()); }
        / &lt; . &gt;        { putchar(yytext[0]); }
</pre>
<p>The first line instructs the parser to print the user's login name whenever it sees &quot;username&quot; in the input. If that match fails,  the second line tells the parser to echo the next character on the input the standard output.  Our parser is now performing useful work: it will copy  the  input to the output, replacing all occurrences of &quot;username&quot; with the user's account name.</p>
<p>Note the angle brackets ('&lt;' and '&gt;') that were  added  to  the  second alternative.  These  have  no  effect  on the meaning of the rule, but serve to delimit the text made available to the following action in the variable yytext.</p>
<p>如果上面所示的语法编写在文件 <tt class="docutils literal">username.peg</tt> 中, 运行如下命令:</p>
<pre class="literal-block">
peg -o username.c username.peg
</pre>
<p>将会把相应的解析引擎存储在 <tt class="docutils literal">username.c</tt> 文件中. To create a complete  program  this parser could be included by a C program as follows:</p>
<pre class="literal-block">
#include &lt;stdio.h&gt;      /* printf(), putchar() */
#include &lt;unistd.h&gt;    /* getlogin() */

#include &quot;username.c&quot;  /* yyparse() */

int main()
{
  while (yyparse())    /* repeat until EOF */
    ;
  return 0;
}
</pre>
</div>
<div class="section" id="peg">
<h1><a class="toc-backref" href="#id8">PEG语法</a></h1>
<p>一种语法是由一组命名的规则组成, 如下所示的就是一条规则:</p>
<pre class="literal-block">
name &lt;- pattern
</pre>
<ul>
<li><p class="first"><tt class="docutils literal">name</tt></p>
<p>规则的名称.</p>
</li>
<li><p class="first"><tt class="docutils literal">pattern</tt></p>
<p>描述规则的一种表达式.</p>
</li>
<li><p class="first"><tt class="docutils literal">&quot;characters&quot;</tt></p>
<p>A  character or string enclosed in double quotes is matched literally.  The ANSI C escape sequences are recognised  within  the characters.</p>
</li>
</ul>
<dl class="docutils">
<dt><tt class="docutils literal">'characters'</tt></dt>
<dd>A  character or string enclosed in single quotes is matched literally, as above.</dd>
</dl>
<ul class="simple">
<li><tt class="docutils literal">[characters]</tt></li>
</ul>
<p>A set of characters enclosed in square brackets matches any single character from the set, with escape characters recognised as above.</p>
<p>被破折号(-)连接的一对字符则表示字符的范围. 如下示例表示一个字母型字符:</p>
<pre class="literal-block">
[a-zA-Z]
</pre>
<p>如果在一个集合的起始位置加一个符号(^)则表示反义的(说明这个字符不在该集合中). 如下表达式匹配一个任意非数字的字符:</p>
<pre class="literal-block">
[^0-9]
</pre>
<ul class="simple">
<li><tt class="docutils literal">.</tt></li>
</ul>
<p>点号(.)匹配任意单个字符. 需要注意的是, 匹配到文件的结尾时会失败, 因为文件尾没有任何字符可以匹配.</p>
<ul class="simple">
<li><tt class="docutils literal">( pattern )</tt></li>
</ul>
<p>圆括号用于将 <tt class="docutils literal">pattern</tt> 分组, 提高圆括号内部表达式的优先级.</p>
<ul class="simple">
<li><tt class="docutils literal">{ action }</tt></li>
</ul>
<p><tt class="docutils literal">action</tt> 被一对大括号包围. <tt class="docutils literal">action</tt> 实际上就是一段可执行的C代码Curly braces surround actions.  The action is arbitrary C source code  to  be executed at the end of matching.  Any braces within the action must be properly nested.  Any  input  text  that  was matched  before  the action and delimited by angle brackets (see below) is made available within the action as  the  contents  of the character array yytext. <tt class="docutils literal">yyleng</tt> 表示 <tt class="docutils literal">yytext</tt> 字符串的长度(字符数).</p>
<ul class="simple">
<li><tt class="docutils literal">&lt;</tt> 和 <tt class="docutils literal">&gt;</tt></li>
</ul>
<p>两个尖括号之间的文本会被放到 <tt class="docutils literal">action</tt> 中的变量 <tt class="docutils literal">yytext</tt> 中.</p>
<p>The  above elements and suffixes can be converted into predicates (that match arbitrary input text and subsequently  succeed  or  fail  without consuming that input) with the following prefixes:</p>
<ul class="simple">
<li><tt class="docutils literal">&amp; element</tt></li>
</ul>
<p>只有``element`` 匹配才会断言成功. Input text scanned while matching element is  not  consumed  from  the input and remains available for subsequent matching.</p>
<ul class="simple">
<li><tt class="docutils literal">! element</tt></li>
</ul>
<p>只有``element`` 不匹配才会断言成功. Input text scanned while matching element is  not  consumed  from  the input  and remains available for subsequent matching.  常见用法 <tt class="docutils literal">!.</tt> 代表文件的结尾.</p>
<p>A special form of the '&amp;' predicate is provided:</p>
<ul class="simple">
<li><tt class="docutils literal">&amp;{ expression }</tt></li>
</ul>
<p>In  this  predicate  the  simple C expression (not statement) is evaluated immediately when the parser reaches the predicate.  If the  expression  yields non-zero (true) the 'match' succeeds and the parser continues with the next element in the  pattern.  If the  expression  yields  zero  (false) the 'match' fails and the parser backs up to look for an alternative parse of the input.</p>
<p>Several elements (with or without prefixes and suffixes)  can  be  combined  into a sequence by writing them one after the other.  The entire sequence matches only if each individual  element  within  it  matches,from left to right.</p>
<p>Sequences can be separated into disjoint alternatives by the alternation operator '/'.</p>
<ul class="simple">
<li>序列-1 / 序列-2 / ... / 序列-N</li>
</ul>
<p>OR运算表达式中的每个序列都会尝试匹配,直到其中一个匹配成功. 如果有一个匹配成功则代表整个表达式匹配成功, 如果一个都没有则表示整个表达式匹配失败.</p>
<p>最后,井号(#, pound sign)代表注释, 直到行尾.</p>
<p>To summarise the above, the  parser  tries  to  match  the  input  text against  a  pattern  containing  literals,  names  (representing  other rules), and various operators (written as prefixes, suffixes,  juxtaposition  for  sequencing and and infix alternation operator) that modify how the elements within the pattern are matched.  Matches are made from left to  right,  'descending' into named sub-rules as they are encountered.  If  the  matching  process  fails,  the  parser 'back  tracks'('rewinding'  the input appropriately in the process) to find the nearest alternative 'path' through the grammar. In other words the  parser performs a depth-first,left-to-right search for the first successfully-matching path through the rules.  If found, the actions along the successful path are executed (in the order they were encountered).</p>
<p>Note  that predicates are evaluated immediately during the search for a successful match, since they contribute to the success  or  failure  of the  search.  Actions,  however, are evaluated only after a successful match has been found.</p>
</div>
<div class="section" id="leg">
<h1><a class="toc-backref" href="#id9">LEG语法</a></h1>
<p>LEG是PEG的一个变种, 增加了一些lex和yacc的特性. 下面这些是与PEG不同的地方:</p>
<ul class="simple">
<li><tt class="docutils literal">%{ <span class="pre">text...</span> %}</tt></li>
</ul>
<p>A declaration section can appear anywhere that a rule definition is  expected.  The text between the delimiters '%{' and '%}' is copied verbatim to the generated C parser code before  the  code that implements the parser itself.</p>
<ul>
<li><dl class="first docutils">
<dt><tt class="docutils literal">name = pattern</tt></dt>
<dd><p class="first last">在LEG语法中使用符号'|'代替符号'/'.</p>
</dd>
</dl>
</li>
<li><p class="first"><tt class="docutils literal"><span class="pre">rule-name</span></tt></p>
<p>Hyphens  can  appear  as  letters  in  the names of rules.  Each hyphen is converted into an underscore in the generated C source code.  A single single hyphen '-' is a legal rule name:</p>
<pre class="literal-block">
-      = [ \t\n\r]*
number  = [0-9]+                -
name    = [a-zA-Z_][a-zA_Z_0-9]* -
l-paren = '('                    -
r-paren = ')'                    -
</pre>
</li>
</ul>
<p>This  example  shows  how ignored whitespace can be obvious when reading the grammar and yet unobtrusive when placed liberally at the end of every rule associated with a lexical element.</p>
<ul>
<li><p class="first"><tt class="docutils literal"><span class="pre">seq-1</span> | <span class="pre">seq-2</span></tt></p>
<blockquote>
<p>The alternation operator is vertical bar '|' rather than forward slash '/'.  The peg rule:</p>
<pre class="literal-block">
name &lt;- sequence-1
      / sequence-2
      / sequence-3
</pre>
<p>is therefore written:</p>
<pre class="literal-block">
name = sequence-1
    | sequence-2
    | sequence-3
    ;
</pre>
<p>in leg (with the final semicolon being  optional,  as  described next).</p>
</blockquote>
</li>
<li><p class="first"><tt class="docutils literal">exp ~ { action }</tt></p>
</li>
</ul>
<p>A  postfix  operator ~{ action } can be placed after any expression and will behave like a normal  action  (arbitrary  C  code) except  that  it  is invoked only when exp fails.  It binds less tightly than any other operator except alternation and  sequencing,  and  is  intended to make error handling and recovery code easier to write.  Note that yytext and yyleng are not  available inside  these  actions, but the pointer variable yy is available to give the code access  to  any  user-defined  members  of  the parser  state  (see  &quot;CUSTOMISING THE PARSER&quot; below).  Note also that exp is always a  single  expression;  to  invoke  an  error action  for  any  failure within a sequence, parentheses must be used to group the sequence into a single expression.</p>
<blockquote>
<dl class="docutils">
<dt>rule = e1 e2 e3 ~{ error(&quot;e[12] ok; e3 has failed&quot;); }</dt>
<dd><div class="first last line-block">
<div class="line">...</div>
</div>
</dd>
<dt>rule = (e1 e2 e3) ~{ error(&quot;one of e[123] has failed&quot;); }</dt>
<dd><div class="first last line-block">
<div class="line">...</div>
</div>
</dd>
</dl>
</blockquote>
<ul class="simple">
<li>pattern ;</li>
</ul>
<p>A semicolon punctuator can optionally terminate a pattern.</p>
<ul class="simple">
<li><tt class="docutils literal">%% <span class="pre">text...</span></tt></li>
</ul>
<p>两个百分号'%%'表示语法段中规则描述的结束. 符号'%%'后面所有的文本会原封不动的拷贝到自动生成的C解析代码的对应位置上.</p>
<ul class="simple">
<li><tt class="docutils literal">$$ = value</tt></li>
</ul>
<p>该伪变量('$$')表示子级规则中 <tt class="docutils literal">action</tt> 的返回值.  所有该返回值的类型必须相同(其缺省类型为'int').  这个伪变量的类型可以通过预定义YYSTYPE来改变.</p>
<ul class="simple">
<li><tt class="docutils literal">identifier:name</tt></li>
</ul>
<p>子级规则的返回值(通过赋值给'$$')将关联到标识符identifier上, 然后能够在随后的 <tt class="docutils literal">action</tt> 中被引用.</p>
<p>在后续&quot;桌面计算机&quot;示例中说明了'$$' 和 ':' 的用法.</p>
</div>
<div class="section" id="id2">
<h1><a class="toc-backref" href="#id10">自定义解析器</a></h1>
<p>为了修改生成的解析代码,下面这些符号可以在声明部分被重新定义:</p>
<ul class="simple">
<li><tt class="docutils literal">YYSTYPE</tt></li>
</ul>
<p>定义 <tt class="docutils literal">semantic value</tt> 的类型. 伪变量 '$$' 和 <tt class="docutils literal">identifier:name</tt> 中的 <tt class="docutils literal">identifier</tt> 都使用该定义的类型. 缺省值为'int'.</p>
<ul class="simple">
<li><tt class="docutils literal">YYPARSE</tt></li>
</ul>
<p>解析的主入口. 缺省值为'yyparse'.</p>
<ul class="simple">
<li><tt class="docutils literal">YYPARSEFROM</tt></li>
</ul>
<p>解析的辅入口. This function expects one argument: the function corresponding to the rule from which the  search  for  a  match  should  begin.  The default is 'yyparsefrom'.  注意 <tt class="docutils literal">yyparse()</tt> 被实现为如下形式:</p>
<pre class="literal-block">
int yyparse() { return yyparsefrom(yy_foo); }
</pre>
<p>where 'foo' is the name of the first rule in the grammar.</p>
<ul class="simple">
<li><tt class="docutils literal">YY_INPUT(buf, result, max_size)</tt></li>
</ul>
<dl class="docutils">
<dt>This  macro  is invoked by the parser to obtain more input text.</dt>
<dd><p class="first">buf points to an area of memory that can hold at  most  max_size
characters.  The  macro  should copy input text to buf and then
assign the integer variable result to  indicate  the  number  of
characters  copied.  If  no  more input is available, the macro
should assign 0 to result.  By default, the  YY_INPUT  macro  is
defined as follows:</p>
<pre class="last literal-block">
#define YY_INPUT(buf, result, max_size)        \
{                                              \
  int yyc= getchar();                          \
  result= (EOF == yyc) ? 0 : (*(buf)= yyc, 1); \
}
</pre>
</dd>
</dl>
<p>Note  that  if YY_CTX_LOCAL is defined (see below) then an additional first argument, containing the parser context, is  passed to YY_INPUT.</p>
<ul class="simple">
<li><tt class="docutils literal">YY_DEBUG</tt></li>
</ul>
<p>If this symbols is defined then additional code will be included in the parser that prints vast quantities of arcane  information to the standard error while the parser is running.</p>
<ul class="simple">
<li><tt class="docutils literal">YY_BEGIN</tt></li>
</ul>
<p>This  macro is invoked to mark the start of input text that will be made available in actions as 'yytext'.  This  corresponds  to occurrences  of  '&lt;'  in  the grammar.  These are converted into predicates that are expected to succeed.  The default definition:</p>
<pre class="literal-block">
#define YY_BEGIN (yybegin= yypos, 1)
</pre>
<p>therefore  saves  the  current  input  position  and  returns  1('true') as the result of the predicate.</p>
<ul class="simple">
<li><tt class="docutils literal">YY_END</tt></li>
</ul>
<p>This  macros  corresponds to '&gt;' in the grammar.  Again, it is a predicate so the default definition  saves  the  input  position before 'succeeding':</p>
<pre class="literal-block">
#define YY_END (yyend= yypos, 1)
</pre>
<ul class="simple">
<li><tt class="docutils literal">YY_PARSE(T)</tt></li>
</ul>
<p>该宏定义了解析的入口.This  macro  declares  the  parser  entry  points  (yyparse  and yyparsefrom) to be of type T.  The default definition:</p>
<pre class="literal-block">
#define YY_PARSE(T) T
</pre>
<p>leaves yyparse() and yyparsefrom() with global  visibility.  If they  should  not  be  externally visible in other source files,this macro can be redefined to declare them 'static':</p>
<pre class="literal-block">
#define YY_PARSE(T) static T
</pre>
<ul>
<li><p class="first"><tt class="docutils literal">YY_CTX_LOCAL</tt></p>
<blockquote>
<blockquote>
<p>If this symbol is defined  during  compilation  of  a  generated
parser  then  global parser state will be kept in a structure of
type 'yycontext' which can be  declared  as  a  local  variable.
This  allows  multiple instances of parsers to coexist and to be
thread-safe.  The parsing function yyparse() will be declared to
expect  a  first  argument of type 'yycontext <a href="#id3"><span class="problematic" id="id4">*</span></a>', an instance of
the structure holding the global state  for  the  parser.  This
instance  must  be  allocated  and  initialised  to  zero by the
client.  A trivial but complete example is as follows:</p>
<div class="system-message" id="id3">
<p class="system-message-title">System Message: WARNING/2 (<tt class="docutils">/var/folders/_5/lklyfhds58543mj_w_zd90fm0000gn/T/peg_leg_parser.rst</tt>, line 303); <em><a href="#id4">backlink</a></em></p>
<p>Inline emphasis start-string without end-string.</p>
</div>
<pre class="literal-block">
#include &lt;stdio.h&gt;

#define YY_CTX_LOCAL

#include &quot;the-generated-parser.peg.c&quot;

int main()
{
  yycontext ctx;
  memset(&amp;ctx, 0, sizeof(yycontext));
  while (yyparse(&amp;ctx));
  return 0;
}
</pre>
<p>Note that if this symbol is undefined then the  compiled  parser
will  statically  allocate  its global state and will be neither
reentrant nor thread-safe.  Note also that the parser  yycontext
structure  is initialised automatically the first time yyparse()
is called; this structure must therefore be properly initialised
to zero before the first call to yyparse().</p>
</blockquote>
<dl class="docutils">
<dt>YY_CTX_MEMBERS</dt>
<dd><p class="first last">If  YY_CTX_LOCAL  is  defined  (see  above)  then  the  macro
YY_CTX_MEMBERS can be defined to expand to any additional member
field  declarations  that  the client would like included in the
declaration of the 'yycontext' structure type.  These additional
members  are  otherwise  ignored  by  the generated parser.  The
instance of 'yycontext'  associated  with  the  currently-active
parser is available within actions as the pointer variable yy.</p>
</dd>
<dt>YY_BUFFER_SIZE</dt>
<dd><p class="first last">The  initial  size of the text buffer, in bytes.  The default is
1024 and the buffer size is doubled whenever  required  to  meet
demand  during  parsing.  An  application that typically parses
much longer strings could increase  this  to  avoid  unnecessary
buffer reallocation.</p>
</dd>
<dt>YY_STACK_SIZE</dt>
<dd><p class="first last">The initial size of the variable and action stacks.  The default
is 128, which is doubled whenever required to meet demand during
parsing.  Applications  that  have  deep  call stacks with many
local variables, or that perform many  actions  after  a  single
successful  match, could increase this to avoid unnecessary buf-
fer reallocation.</p>
</dd>
<dt>YY_MALLOC(YY, SIZE)</dt>
<dd><p class="first last">The memory allocator for all parser-related storage.  The param-
eters  are  the  current  yycontext  structure and the number of
bytes to allocate.  The default definition is: malloc(SIZE)</p>
</dd>
<dt>YY_REALLOC(YY, PTR, SIZE)</dt>
<dd><p class="first last">The memory reallocator for dynamically-grown  storage  (such  as
text  buffers and variable stacks).  The parameters are the cur-
rent yycontext structure, the previously-allocated storage,  and
the  number of bytes to which that storage should be grown.  The
default definition is: realloc(PTR, SIZE)</p>
</dd>
<dt>YY_FREE(YY, PTR)</dt>
<dd><p class="first last">The memory deallocator.  The parameters are the  current  yycon-
text structure and the storage to deallocate.  The default defi-
nition is: free(PTR)</p>
</dd>
<dt>YYRELEASE</dt>
<dd><p class="first last">The name of the function that releases all resources held  by  a
yycontext structure.  缺省值为'yyrelease'.</p>
</dd>
</dl>
</blockquote>
</li>
</ul>
<p>如下变量可以在action中被引用:</p>
<ul class="simple">
<li><tt class="docutils literal">char *yybuf</tt></li>
</ul>
<p>This  variable points to the parser's input buffer used to store input text that has not yet been matched.</p>
<ul class="simple">
<li><tt class="docutils literal">int yypos</tt></li>
</ul>
<p>这个变量指向了在 <tt class="docutils literal">yybuf</tt> 中下一个要被匹配和消费的字符的位置.</p>
<ul class="simple">
<li><tt class="docutils literal">char *yytext</tt></li>
</ul>
<p>两个尖括号之间的文本会被放到 <tt class="docutils literal">action</tt> 中的变量 <tt class="docutils literal">yytext</tt> 中.</p>
<ul class="simple">
<li><tt class="docutils literal">int yyleng</tt></li>
</ul>
<p>这个变量表示 <tt class="docutils literal">yytext</tt> 变量中字符的数目.</p>
<ul class="simple">
<li><tt class="docutils literal">yycontext *yy</tt></li>
</ul>
<p>This variable points to the instance of  'yycontext'  associated with the currently-active parser.</p>
<p>Programs  that  wish  to  release  all  the resources associated with a parser can use the following function.</p>
<ul class="simple">
<li><tt class="docutils literal">yyrelease(yycontext *yy)</tt></li>
</ul>
<p>Returns all parser-allocated storage associated with yy to the system.  The storage will be reallocated on the next call to yyparse().</p>
<p>Note that the storage for the yycontext structure itself is never allocated  or  reclaimed  implicitly.  The application must allocate these structures in automatic storage, or use calloc() and free()  to  manage them explicitly.  The example in the following section demonstrates one approach to resource management.</p>
</div>
<div class="section" id="leg-example-extending-the-parser-s-context">
<h1><a class="toc-backref" href="#id11">LEG EXAMPLE: EXTENDING THE PARSER'S CONTEXT</a></h1>
<p>The yy variable passed to actions contains the state of the parser plus any  additional fields defined by YY_CTX_MEMBERS.  Theses fields can be used to store application-specific information that is global to a particular  call of yyparse().  A trivial but complete leg example follows in which the yycontext structure is extended with a count of the number of  newline  characters seen in the input so far (the grammar otherwise consumes and ignores the entire input).  The caller of  yyparse() uses count to print the number of lines of input that were read:</p>
<pre class="literal-block">
%{
#define YY_CTX_LOCAL 1
#define YY_CTX_MEMBERS \
  int count;
%}

Char    = ('\n' | '\r\n' | '\r')        { yy-&gt;count++ }
        | .

%%

#include &lt;stdio.h&gt;
#include &lt;string.h&gt;

int main()
{
    /* create a local parser context in automatic storage */
    yycontext yy;
    /* the context *must* be initialised to zero before first use*/
    memset(&amp;yy, 0, sizeof(yy));

    while (yyparse(&amp;yy))
        ;
    printf(&quot;%d newlines\n&quot;, yy.count);

    /* release all resources associated with the context */
    yyrelease(&amp;yy);

    return 0;
}
</pre>
</div>
<div class="section" id="diagnostics">
<h1><a class="toc-backref" href="#id12">DIAGNOSTICS</a></h1>
<p>peg  and  leg  warn  about  the following conditions while converting a grammar into a parser.</p>
<dl class="docutils">
<dt>语法错误</dt>
<dd>The input grammar was malformed in some way.  The error  message
will  include  the  text  about to be matched (often backed up a
huge amount from the actual location of the error) and the  line
number of the most recently considered character (which is often
the real location of the problem).</dd>
<dt>规则xx被引用但是未定义</dt>
<dd>The grammar referred to a rule named 'foo' but no definition for
it  was  given.  Attempting  to  use  the generated parser will
likely result in errors from the linker due to undefined symbols
associated with the missing rule.</dd>
<dt>规则xx已定义但是未使用</dt>
<dd>The grammar defined a rule named 'foo' and then ignored it.  The
code associated with the  rule  is  included  in  the  generated
parser which will in all other respects be healthy.</dd>
<dt>possible infinite left recursion in rule 'foo'</dt>
<dd>There  exists  at  least one path through the grammar that leads
from the rule 'foo' back to (a recursive invocation of) the same
rule without consuming any input.</dd>
</dl>
<p>Left  recursion, especially that found in standards documents, is often 'direct' and implies trivial repetition:</p>
<pre class="literal-block">
# (6.7.6)
direct-abstract-declarator =
    LPAREN abstract-declarator RPAREN
|  direct-abstract-declarator? LBRACKET assign-expr? RBRACKET
|  direct-abstract-declarator? LBRACKET STAR RBRACKET
|  direct-abstract-declarator? LPAREN param-type-list? RPAREN
</pre>
<p>The recursion can easily be eliminated by converting the parts  of  the  pattern following the recursion into a repeatable suffix:</p>
<pre class="literal-block">
# (6.7.6)
direct-abstract-declarator =
    direct-abstract-declarator-head?
    direct-abstract-declarator-tail*

direct-abstract-declarator-head =
    LPAREN abstract-declarator RPAREN

direct-abstract-declarator-tail =
    LBRACKET assign-expr? RBRACKET
|  LBRACKET STAR RBRACKET
|  LPAREN param-type-list? RPAREN
</pre>
</div>
<div class="section" id="id5">
<h1><a class="toc-backref" href="#id13">使用注意事项</a></h1>
<p>A  parser  that  accepts empty input will always succeed. 看看下面这个例子, 典型的基于LEG的解析器:</p>
<pre class="literal-block">
Program = Expression*
Expression = &quot;whatever&quot;
%%

int main() {
  while (yyparse())
    puts(&quot;success!&quot;);
  return 0;
}
</pre>
<p>This  program  loops forever, no matter what (if any) input is provided on stdin.  Many fixes are possible, the easiest being  to  insist  that the  parser  always  consumes some non-empty input.  将第一行更改为:</p>
<pre class="literal-block">
Program = Expression+
</pre>
<p>accomplishes this.  If the parser is expected  to  consume  the  entire input,  强烈建议增加文件尾标识:</p>
<pre class="literal-block">
Program = Expression+ !.
</pre>
<p>This works because the parser will only fail to match  (&quot;!&quot;  predicate) any  character  at all (&quot;.&quot; expression) when it attempts to read beyond the end of the input.</p>
</div>
<div class="section" id="id6">
<h1><a class="toc-backref" href="#id14">Leg解析语法示例: 桌面型计算器</a></h1>
<p>The extensions in leg described above allow useful parsers and  evaluators (including declarations, grammar rules, and supporting C functions such as 'main') to be kept within a single source file.  To  illustrate this we show a simple desk calculator supporting the four common arithmetic operators and  named  variables.  The  intermediate  results  of arithmetic  evaluation  will  be  accumulated  on  an implicit stack by returning them as semantic values from sub-rules:</p>
<pre class="literal-block">
%{
    #include &lt;stdio.h&gt;    /* printf() */
    #include &lt;stdlib.h&gt;    /* atoi() */
    int vars[26];
%}

Stmt    = - e:Expr EOL                 { printf(&quot;%d\n&quot;, e); }
        | ( !EOL . )* EOL              { printf(&quot;error\n&quot;); }

Expr    = i:ID ASSIGN s:Sum            { $$ = vars[i] = s; }
         s:Sum                         { $$ = s; }

Sum    = l:Product
                      ( PLUS  r:Product      { l += r; }
                      | MINUS r:Product      { l -= r; }
                      )*                      { $$ = l; }

Product = l:Value
                      ( TIMES  r:Value        { l *= r; }
                      | DIVIDE r:Value        { l /= r; }
                      )*                      { $$ = l; }

Value  = i:NUMBER                      { $$ = atoi(yytext); }
              | i:ID !ASSIGN                  { $$ = vars[i]; }
              | OPEN i:Expr CLOSE            { $$ = i; }

NUMBER  = &lt; [0-9]+ &gt;    -              { $$ = atoi(yytext); }
ID      = &lt; [a-z]  &gt;    -              { $$ = yytext[0] - 'a'; }
ASSIGN  = '='          -
PLUS    = '+'          -
MINUS  = '-'          -
TIMES  = '*'          -
DIVIDE  = '/'          -
OPEN    = '('          -
CLOSE  = ')'          -

-      = [ \t]*
EOL    = '\n' | '\r\n' | '\r' | ';'

%%

int main()
{
    while (yyparse())
            ;
    return 0;
}
</pre>
</div>

    </body>
</html>
